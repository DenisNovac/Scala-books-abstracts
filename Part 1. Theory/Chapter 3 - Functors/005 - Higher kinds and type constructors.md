# Higher kinds (типы высшего рода) и конструкторы типов.

> *`F[_]` - это параметр типа, как и любой другой параметр, при вызове он может принять конкретный аргумент - тип. Отличие от простых "дженериков"  в том, что это так называемый "тип высшего рода". Если строить аналогию с обычными параметрами он принимает на вход не просто значение, а функцию типа. `F[_]` означает - функция типа, принимающая один тип - аргумент. Пока ты не передашь ей этот аргумент, ты не имеешь право типизировать ей переменные. Т.е. написать `x: F[Int]` можно, а `x : F` - нельзя.* - из https://t.me/scala_learn

Типы высшего порядка - это что-то вроде типов для типов. Они определяют количество "дырок" в типе. 

Следует отличать обычные типы (без дырок) и "конструкторы типов", которые имеют дырки, которые можно заполнять для получения типов. 

Например: `List` это конструктор типа с одной дыркой. Если её заполнить - мы получим обычный тип `List[Int]` или вроде того. Но конструкторы типов это не то же, что обобщённые типы. `List` - конструктор типа, `List[A]` - тип. 

В `Scala` мы описываем конструкторы типов через нижнее подчёркивание. После этого мы обращаемся к ним как обычно:

```scala
def myMethod[F[_]] = {
	val functor = Functor.apply[F]
}
```

Теперь мы можем понять, что определение функтора позволяет создавать инстансы для любого однопараметрового конструктора типов вроде `List`, `Option`, `Future`...

> `Higher kinded types` считаются продвинутой фичей, поэьтому для их использования нужно импортировать `scala.language.higherKinds` или добавить опцию `scalacOptions += "-language:higherKinds"` чтобы избавиться от ворнингов.