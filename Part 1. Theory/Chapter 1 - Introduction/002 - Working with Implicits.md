# Работа с имплиситами

Работа с тайпклассами в Scala означает работу с имплиситными значениями и параметрами. Нужно знать несколько правил чтобы делать это эффективно.

## Упаковка имплиситов

Из-за особенностей языка, любое определение, обозначенное `implicit` в Scala должно быть помещено внутри объекта или трейта, а не на верхнем уровне. Поэтому ранее мы паковали класс инстансов в `JsonWriterInstances` объект и потом импортировали его. Альтернативным решением было бы расположение имплиситов в объекте-компаньоне самого тайпкласса `JsonWriter`:

```scala
// сам тайпкласс
trait JsonWriter[A] {
  def write(value: A): Json
}
```

Помещение интсансов в объект-компаньон тайпкласса имеет особое значение, поскольку оно образует *implicit scope* (область видимости неявных значений).

### Область видимости имплиситов

Компилятор ищет тайпклассы-кандидаты по типу. Например:

```scala
object Json {
  def toJson[A](value: A)(implicit w: JsonWriter[A]): Json = 
    w.write(value)
}

Json.toJson("A string")
```

Компилятор будет искать кандидатов в области видимости, которая, грубо говоря, состоит из:

- Локальных или унаследованных определений;
- Импортированных определений;
- Определений в объекте-компаньоне тайпкласса или типа параметра (в данном случае это будет `JsonWriter` либо `String`).

Определения являются частью области видимости имплиситов только если они имеют ключевое слово implicit. Если подходящих кандидатов больше одного - произойдёт ошибка "ambigous implicit values". Разрешение имплиситов довольно сложная процедура, но для книги ограничимся грубыми правилами упаковки инстансов тайпклассов:

1. Помещать их в объекты вроде JsonWriterInstances;
2. Помещать их в трейт;
3. Помещать их в объект-компаньон тайпкласса;
4. Помещать их в объект-компаньон типа параметра.

При использовании опции 1 мы получаем инстансы путём импорта. При использовании опции 2 - путём наследования. По опцям 3 и 4 инстансы *всегда* в области видимости.

### Рекурсивное разрешение имплиситов

Компилятор способен комбинировать имплиситные определенеия во время поиска кандидатов. Ранее мы считали, что все инстансы тайпклассов - `implicit` значения. Но это не так. Они могут быть:

- `implicit val` или `implicit object`;
- `implicit` методами для конструирования инстансов из инстансов другого тайпкласса.

Зачем создавать инстансы из других инстансов? 

Предположим, мы хотим определить `JsonWriter` для `Option`. Нам нужен будет `JsonWriter[Option[A]]` для каждого нужного `A`. Это трудоёмко, если таких инстансов десятки или сотни.

Поэтому мы можем абстрагироваться до уровня `Option[A]`:

```scala
implicit def optionWriter[A]
  (implicit writer: JsonWriter[A]): JsonWriter[Option[A]] =
    new JsonWriter[Option[A]] {
      def write(option: Option[A]): Json = 
        option match {
          case Some(aValue) => writer.write(aValue)
          case None => JsNull
        }
    }
```

Важно сделать `implicit` как у `def`, так и у его аргумента `implicit writer`, иначе этот имплисит никогда не будет использован (невозможно передать явно аргумент в функцию, которая вызвается неявно и в коде не фигурирует). Компилятор предупреждает о таких местах ворнингами с текстом **implicit conversion method**.

Этот метод создаёт `JsonWriter` для любого `Option[A]`, для которого уже есть `JsonWriter[A]`:

```scala
Json.toJson(Option("A string"))
// =>
Json.toJson(Option("A string"))(optionWriter[String])
// =>
Json.toJson(Option("A string"))(optionWriter(stringWriter))
```

Имплисивное разрешение - это поиск разных веток возможных имплисивных определений. Оно будет успешным, если есть прямая ветка со всеми нужными аргументами. 