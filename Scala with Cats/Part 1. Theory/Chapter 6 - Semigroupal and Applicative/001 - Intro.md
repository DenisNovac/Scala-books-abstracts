# Semigroupal and Applicative

В предыдущих главах было изучено, как функторы и монады позволяют создавать последовательные вычисления через `map` и `flatMap`. Это полезные конструкции, но для некоторых программ не подходят.

Например, валидация формы. Когда мы валидируем формы - мы хотим вернуть все ошибки за раз, а не по одной. Монады вроде `Either` относятся к `fail-fast` конструкциям и не подойдут.

Другой пример - это конкурентное вычисление `Future`. Монадное вычисление позволяет лишь последовательный запуск (`map` и `flatMap` предполагают, что следующее вычисление зависит от предыдущего).

Мы не можем использовать `flatMap` когда нам нужно отсутствие гарантии последовательных вычислений. В этой главе мы рассмотрим два подходящих класса:

- `Semigroupal` - охватывает понятие композирования пар контекстов. Модуль `cats.syntax.apply` позволяет использоавть `Semigroupal` и `Functor` для связывания функций с несколькими аргументами.
- `Applicative` расширяет `Semigroupal` и `Functor`. Он позволяет применять функции к параметрам в контексте и предоставляет метод `pure`.

Аппликативы обычно описываются в понятиях применения к функциям, а не к semigrpupal-ам, как это делается в Cats. Этот альтернативный подход создаёт связь с другими библиотекам и языками вроде Scalaz и Haskell.
