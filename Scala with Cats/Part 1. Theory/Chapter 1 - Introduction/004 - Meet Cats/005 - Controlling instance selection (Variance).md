# Контроль выбираемых инстансов

 При работе с тайпклассами нужно помнить о двух проблемах выбора инстанса:

 - В каких отношениях состоят инстанс типа и его подтипы. Например, если мы определим `JsonWriter[Option[Int]]`, будет ли он выбран при вызове `Json.toJson(Some(1))` (Some - подтип Option)?

 - Как мы выбираем между тайпклассами, когда нам доступно несколько? Что если мы определим два `JsonWriter` для `Person`? Какой инстанс будет выбран?

 ## Вариантность 

 Когда мы определяем тайпклассы мы можем добавить вариантные аннотации к параметру типа чтобы повлиять на выбор компилятора. Вариантность - это понятие, связанное с подтипами. B - подтип A если мы можем использовать B везде, где ожидается A (классическое наследование).

### Ковариантность

```scala
trait List[+A]
trait Option[+A]
```

Ковариантность значит, что тип F[B] это подтип типа F[A] если B это подтип A. Это полезно для моделирования многих вещей. Например, коллекций.

Коллекции в Scala ковариантны.

```scala
sealed trait Shape
case class Circle(radius: Double) extends Shape

var circles: List[Circle] = ???
var shapes: List[Shape] = circles  // - так можно, ковариантность
```

### Контрвариантность

```scala
trait F[-A]
```

Контрвариантность значит, что тип F[B] - это подтип F[A] если A - это подтип B. Это полезно для моделирования типов, означающих процессы вроде JsonWriter:

```scala
trait JsonWriter[-A] {
  def write(value: A): Json
}
```

Снова вернёмся к формам:

```scala
sealed trait Shape
case class Circle(radius: Double) extends Shape

var circle: Circle = ???
var shape: Shape = ???

val shapeWriter: JsonWriter[Shape] = ???
val circleWriter: JsonWriter[Circle] = ???

def format[A](value: A, writer: JsonWriter[A]): Json =
  writer.write(value)
```

Какие комбинации значения и Writer-а можно передать в `format`? Мы можем скомбинировать circle с любым writer-ом потому что все `Circle` являются `Shape`. Обратное насправедливо - не каждая `Shape` является `Circle`. 

Это и есть формальное определение контрвариантности. `JsonWriter[Shape]` это подтип `JsonWriter[Circle]` потому что `Circle` это подтип `Shape`. Это значит, что мы можем использовать `shapeWriter` там, где мы ожидаем `JsonWriter[Circle]`.

### Инвариантность

Инвариантность это просто

```scala
trait F[A]
```

Тогда типы F[A] и F[B] никогда не будут сабтипами друг друга.

Когда компилятор ищет имлиситы - он ищет совпадение по типу или *подтипу*. Поэтому мы можем использовать вариантность чтобы контролировать выбор.

Есть две проблемы

```scala
sealed trait A

final case object B extends A
final case object C extends A
```

1. Будет ли инстанс супертипа в принципе выбираться, если такой есть. Например, можем ли мы определить инстанс A и ожидать, что компилятор будет выбирать его для значений B и C?
2. Будет ли инстанс подтипа приоритетен по сравнению с инстансом супертипа? Например, если у нас есть инстансы A и B и значение типа B - выберет ли компилятор инстанс именно для B или оба подойдут?

Оказывается, нельзя решить обе проблемы разом.

- Инстанс **супертипа** используется только при **контрвариантности**;
- **Конкретный инстанс** типа используется только при **ковариантности**.

Cats обычно предпочитает использовать инвариантные классы. Это позволяет выбирать более специфичные инстансы для сабтипов. Это значит, что если мы имеем значение `Some[Int]`, тайпкласс для `Option` использован не будет. Мы можем решить эту проблему через аннотацию `Some(1) : Option[Int]`.