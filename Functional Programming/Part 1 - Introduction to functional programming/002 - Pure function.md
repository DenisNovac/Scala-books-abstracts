# Чистые функции

Ранее мы говорили, что чистая функция - это функция без побочных эффектов. Теперь мы формализуем это понятие чтобы понять что значит программировать функциональные программы. 

Функция `f` с типом аргумента `A` и выводом `B` (или, как написали бы на Scala, `A => B`) - это вычисление, которое соотносит каждому значению типа `A` определённое и единственное значение типа `B`. Внешние процессы программы не могут влиять на возвращаемое значение. 

Иначе говоря, если функция не оказывает видимых эффектов на выполнение программы за исключением возврата значения, мы говорим, что у функции нет побочных эффектов. В фп называть функции "чистыми" в целом избыточно, потому что это то, какими они предполагаются по умолчанию. 

Мы можем сформировать определение чистых функций используя концепцию *ссылочной прозрачности* (*Referential transparency, (RT)*). Это понятие относится не только к функциям, но и к *выражениям*. Выражение - это всё, что можно вписать в интерпретатор Scala и получить ответ. Ссылочная прозрачность означает, что если заменить выражение на результат его выполнения - результат работы программы не изменится. Например, вместо `2 + 3` можно написать `5`. Но возможно это только если функция `+` не имеет побочных эффектов. Таким образом:

> Если вызов функции с ссылочно прозрачными аргументами даёт ссылочно прозрачный результат - она является чистой. 

Посмотрим, как RT соотносится с нашим примером:

```scala
def buyCoffee(cc: CreditCard): Coffee = {
  val cup = new Coffee()
  cc.charge(cup.price)
  cup
}
```

Независимо от типа `cc.charge(cup.price)`, он отбрасывается. Остаётся только возвращённый `cup` типа `Coffee`. Чтобы эта функция была чистой, согласно ссылочной прозрачности, должно выполняться для любой программы `p`:

```scala
p(buyCoffee(aliceCredit)) == p(new Coffee())
```

Однако, это не так. `new Coffee()` никак не взаимодействует с банком, как это делает `buyCoffee`. 

Ссылочная прозрачность означает, что всё, что **делает** функция выражается значением, которое она **возвращает**.

Эта конструкция позволяет использовать *модель подстановок* (*substitution model*) при изучении работы программ. Когда все функции ссылочно-прозрачны, мы можем легко понимать ход работы программ, заменяя переменные на результаты как при решении уравнений в алгебре.

Примером отсутсвия ссылочной прозрачности может послужить `StringBuilder`:

```scala

val x = new StringBuilder("Hello")

val r1 = x.append(", World").toString

// Hello, World

val r2 = x.append(", World").toString

// Hello, World, World

/* Заменим x на выражение, которое он считает */

val r3 = new StringBuilder("Hello").append(", World").toString

// Hello, World

val r4 = new StringBuilder("Hello").append(", World").toString

// Hello, World

```

На самом деле, r1 и r2 ссылаются на разные значения `x`. Когда происходит первый `append` - значение `x` изменяется. Поэтому `r2` ссылается на новый `x`, созданный при вычислении `r1`. Происходит "мутация" памяти - побочный эффект функции `append`. В данной ситуации модель подстановок не будет работать, ведь в разных местах программы значение переменной может мутировать.

Модель подстановок работает когда эффекты *исключительно локальны* - затрагивают только выражение, которое непосредственно вычисляется. Понимаение требует только чтения текущего кода. Не нужно в голове прокручивать все места, где могло измениться состояние. 

Вот почему чистые функциональные программы реюзабельны и композируемы - их отдельные функции могут быть использованы где угодно независимо от внешнего кода. 
