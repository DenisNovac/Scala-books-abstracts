# Что такое функциональное программирование

**Функциональное программирование (FP)** базируется на простом принципе - использовании только *чистых функций* без посторонних эффектов (сайд-эффектов). Ими могут быть:

- Изменение переменной;
- Изменение структуры данных;
- Изменении поля в объекте;
- Бросании эксепшена или падении с ошибкой;
- Вывод в консоль или чтение инпута от юзера;
- Чтение или запись в файл;
- Вывод чего-то на экран.

Кажется, что написание программ без этих условий невозможно. Но ФП ограничивает не то, что можно делать, а то, *как это нужно делать*. Правильное описание этих действий в функциональном стиле ведёт позволяет писать программы **модульно**. Это значит, что их будет легче тестировать, переиспользовать, параллелить, обобщать и понимать.

## Простой пример

Предположим, мы хотим написать программу, которая описывает покупку кофе. Начнём с нечистого кода (001-CoffeExample).

```scala
class Cafe {

  def buyCoffee(cc: CreditCard): Coffee = {
    val cup = new Coffee()
    cc.charge(cup.price) // сайд-эффект: изменение баланса на карте
    cup
  }
}
```

Линия `cc.charge(cup.price)` - это пример побочного эффекта. Мы интерактируем с внешним миром. Например, это может быть соединение с веб-сервисом, авторизация и прочее. Наша функция предназначена только для возврата кофе, оплата картой - это побочное действие для возврата кофе. Отсюда и название - побочный эффект.

Написанный таким образом код сложно тестировать. Мы не хотим, чтобы наши тесты действительно обращались в банк. Эта проблема предполагает решение: знания о том, как платить картой, должны приходить снаружи:

```scala
class Cafe {

  def buyCoffee(cc: CreditCard, p: Payments): Coffee = {
    val cup = new Coffee()
    p.charge(cc, cup.price) // всё ещё сайд-эффект
    cup
  }
}
```

Теперь `Payments` может быть интерфейсом и можно подсунуть в метод специальный тестовый объект, который никуда не ходит. Но это всё равно не лучшее решение. Например, этот класс может иметь какое-то внутреннее состояние, которые мы захотим проверить после вызова `charge`. Тест должен будет проверить, что баланс изменился (*мутировал*). 

Поимо вопросов к тестируемости, такой код тяжело переиспользовать. Предположим, кто-то хочет купить 12 кружек кофе. Тогда мы 12 раз обратимся к банку. Это не очень хорошо.

Конечно, можно написать новую функцию `buyCoffees`, которая будет содержать пакетную логику (*batching*). Проблема в том, что она будет дублировать логику `buyCoffee`. А в реальной ситуации эта логика может быть сложной. 

### Функциональное решение

Функциональное решение состоит в том, чтобы убрать побочные эффекты и заставить функцию возвращать цену в качестве значения вместе с кофе.

```scala
class Cafe {

  def buyCoffee(cc: CreditCard): (Coffee, Charge) = {
    val cup = new Coffee()
    (cup, Charge(cc, cup.price))
  }
}
```

Таким образом, обработка платежа будет вынесена за функцию покупки кофе. Тут мы разделили процессы *создания* платежа и его *обработки*. `Charge` это специальная структура данных, которая содержит цену за кофе, информацию о карте и метод для *комбинирования*. 


```scala
case class Charge(cc: CreditCard, amount: Double) {

  def combine(other: Charge): Charge =
    if (cc = other.cc)
      Charge(cc, amount + other.amount)
    else
      throw new Exception("Can't combine charges to different cards")
}

```

Теперь процедура покупки нескольких кофе может быть оформлена через прежний метод, а не через напсание специального:

```scala
def buyCoffees(cc: CreditCard, n: Int): (List[Coffee], Charge) = {
  // List.fill(n)(...) - n копий содержимого
  val purchases: List[(Coffee, Charge)]                = List.fill(n)(buyCoffee(cc))
  val (coffees, charges): (List[Coffee], List[Charge]) = purchases.unzip

  // reduce используется чтобы схлопнуть лист путём использования функции combine
  // получается, мы возвращаем набор кофе и только один скомбинированный счёт
  (coffees, charges.reduce((c1, c2) => c1.combine(c2)))
}
```

Теперь у нас есть реюзабельные имплементации, которые можно тестировать без написания запутанных моковых имплементаций сервиса платежей. Класс `Cafe` игнорирует как обрабатываются платежи. 

Мы увидели, как можно разделить создание счёта и его обработку. Так можно сделать с любой функцией с побочным эффектом чтобы протолкнуть эти эффекты на другие слои программы. Функциональные программы обычно состоят из чисто-функционального ядра и тонкого слоя с эффектами на поверхности.

