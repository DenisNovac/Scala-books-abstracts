# Примеры

## Inlining

Инлайнинг - это основа всех оптимизаций. Эта операция делает одну простую вещь - заменяет вызов метода его телом.

Такой простой приём открывает много других оптимизацией. Так как вместо вызова с передачей контекста весь контекст оказывается собран - можно понять: 

- какие части метода (ветви) никогда не будут вызваны;
- какие конкретные имплементации обобщённых вызовов используются (возможно, достаточно одного конкретного метода?);
- и подобные.

## Loop unrolling

Эта оптимизация призвана снизить количетсво сравнений в цикле или вообще избавиться от цикла. Например, через переписывание цикла в последовательность одинаковых операций.

```scala
val result = new Array[Int](100)
var i = 0

while (i < result.length) {
  result(i) = 1
  i += 1
}
```

```scala
val result = new Array[Int](100)
var i = 0

while (i < result.length) {
  result(i) = 1
  result(i+1) = 1
  result(i+2) = 1
  i += 3
}
```

## Dead code elimination

Если код никогда не вызвается - код можно убрать. Компилятор может решить сделать это явно (когда вызова метода нет вообще или некоторая переменная всегда true и поэтому ветвь не будет вызвана) или неявно (через профилирование - например, когда ветвь никогда не вызывается во время работы, *untaken brunch pruning*).

Такая оптимизация может быть результатом других:

- **null check elimination** - когда мы проверяем `this == null`, но из контекста это очевидно, поэтому проверка заменяется на `true` или `false`;
  - вариант через профилирование называется **optimistic nullness assertion**;
- **constant folding** - вычисления, основанные на константах, заменяются результатом;
- **inlining** - из инлайна можно собрать весь контекст в одном месте и понять, что какой-то код не вызывается.

Очевидно, для проверки таких оптимизаций (и бенчмарков) нужно использовать различные наборы данных, иначе профилирование может сделать неверные выводы и отбросить нужный в реальности код.

## Escape analysis

Анализирует, выходит ли объект за пределы скоупа, где он был создан.

```scala
class User(name: String, surname: String) {
  def printableName: String = s"$name $surname"
}

class EscapeAnalysis {
  def print2(name1: String, surname1: String, name2: String, surname2: String): String = {
    new User(name1, surname1).printableName + "\n" +
    new User(name2, surname2).printableName
  }
}
```

В данном случае мы создаём юзеров, но не используем их нигде - только вызываем по методу. В этом случае память будет очищена за пределеами print2, как это бы было с примитивами и ссылками в локальных переменных фрейма.

## Mono-, Bi-, Megamorphism and devritualization

В С++ невиртуальный метод имеет один вариант - его можно вызывать без просмотра vtable или даже инлайнить. В Java все методы виртуальны.

- каждый вызов метода JVM запоминает, в каком месте он был вызван;
- какая конкретная имплементация была вызвана.

После сбора статистики JVM может знать, как много имплементаций до сих пор использовалось. Таким образом, можно обнаружить, что определённые имплементации используются только в определённых местах. Дальше JVM делит подобные случаи на категории:

- **мономорфичный вызов**: только одна имплементация используется в этом конкретном месте. Такой метод можно девиртуализировать и инлайнить;
- **бифорфичный вызов**: используется 2 имплементации. Прямая девиртуализация невозможна, но можно использовать if-else с инлайном;
- **мегаморфичный вызов**: 3 и более. Тут нельзя использовать инлайн.

## On Stack Replacement (OSR)

Когда JVM компилирует какой-либо метод - его компилированная версия будет вызвана вместо вызова оргинального метода. Но что, если этот метод никогда не заканчивается? Например, когда в нём бесконечный цикл?

JVM умеет заменять имплементцию уже запущенного в рантайме метода. Делается это между итерациями, для этого JVM добавляет в ассемблерные инструкции специальные дополнительные инструкции, которые JVM использует если будет нужно изменить поток исполнения. Такой приём называется OSR. Он не является оптимизацией сам по себе, просто помогает выполнять их.

## Рефлексия и оптимизации

JVM имеет ограниченные возможности оптимизировать рефлексию. Обычно это относится к Field, Method и Constructor, которые хранятся в переменных, так что JVM через профилирование может понять, что они всегда ходят в один метод/поле.

Однако, обычно рефлексия всё же нарушает работу оптимизаций. JVM часто не может применять профилирование, когда работает рефлексия. Поэтому фреймворки типа Guice или Spring работают медленно и сильно укрепляют стериотипы о том, что Java медленная. Мы сами создали культуру отказа от типобезопасности и скорости.

## Другие оптимизации

На wiki OpenJDK лист оптимизаций достигает 60 техник.



