# Оптимизации

Оптимизации JVM позволяют вещам работать быстрее, чем если бы JVM была просто интерпретатором псевдокода. 

JVM не компилируется в машинный код, но и не выполняется методом интерпретации. JVM отличается от интерпретируемых (JS, Python, PHP) языков тем, что имеет промежуточный этап выполнения - байт-код. Байт-код затем исполняется JVM также как и любая другая программа на интерпретируемом языке. Но поскольку байт-код имеет строго определенный формат, JVM может компилировать его в машинный код прямо во время выполнения. Это называется **Just-In-Time** компиляцией.

## HotSpot

Виртуальная машина Java обеспечивала портативность кода, но была очень медленной.

Затем Sun решили разработать just-in-time компилятор, который будет решать, какие оптимиазации программы будут наиболее выгодны из-за частоты использования кода, а затем компилировать эти инструкции в нативный код. HotSpot появился в Java 1.2 и был включен по умолчанию в Java 1.3. На данный момент HotSpot - самая распространённая JVM.

HotSpot-based JVM:

- Orcale JDK;
- OpenJDK;
- Azul Zulu.

Другие имплементации:

- OpenJ9 (IBM);
- GraalVM (Oracle переписала JVM с нуля с дополнительными фишками).

## C1 и C2

На старте приложения JIT-кода нет. Для начала JVM должна решить, какие части приложения будет наиболее выгодно преобразовать. 

C1 (*client compiler*, флаг `-client`) это первый компилятор, который используется в HotSpot. 

- доступен только в 32-битных имплементациях;
- быстро генерирует достаточно быстрый код;
- не использует профилирование;
- делает базовые оптимизации (inline маленьких методов);
- тривиальные методы до 6 байт в байткоде (`-XX:MaxTrivialSize=6`) инлайнит по умолчанию;
- `private` и `final` методы инлайнит по умолчанию;
- использует линейную аллокацию регистра;
- остальные методы инлайнит до 35 байт (`-XX:MaxInlineSize=35`);
- включается после вызова кода 1500 раз (`-XX:CompileThreshild=1500`).

C2 (*server compiler*, флаг `-server`) это второй компилятор.

Видимо, предполагалось, что клиентские и серверные приложения будут использовать разные компиляторы, но сегодня это неактуально.

- генерирует оптимизированный на высокую скорость код;
- агрессивные оптимизации исходя из профилирования;
- лимит байткода - 325 байт (`-FreqInlineSize=325`), около 30 строк Java;
- использует цветной граф для аллокации регистра;
- включается после вызова кода 10000 раз (`-XX:CompileThreshild=10000`).

JIT имеет большие возможности конфигурации: компиляцию можно ограничить только для некоторых методов или классов, можно компилировать только определённый файл, устанавливать лимит памяти и тредов.

В Java 1.8 предложена уровневая компиляция из C1 + C2 (`-XX:+TieredCompilation`). Появляется несколько уровней компиляции:

- L0 - интерпретатор;
- L1 - C1 компилятор без профилирования для тривиальных методов (6 байт);
- L2 - C1 с базовым профилированием (счётчик вызова методов и циклов);
- L3 - C1 с полным профилированием. Всё что было в L2 плюс счётчик if-else;
- L4 - C2 компилятор.

Можно ограничить уровень `XX:TieredStopAtLevel=1`.

Отладка:

- `-XX:+PrintCompilation` - пишет о том, что метод был компилирован;
- `-XX:+PrintInlining` - пишет об инлайнах;
- `-XX:+PrintAssembly`, `-XX:PrintOptoAssembly` (C2) - JVM будет выводить код ассемблера;
- `-XX:+LogCompilation` - логирует в файл (можно визуализировать JITwatch-ем).

Компиляции выполняются асинхронно с очередью Compiler Task Queue.

