
# Как JVM очищает память

Самый простой вариант - хранить счётчик ссылок для каждой ссылки. Такая модель быстра и может освобождать память в параллели, но у неё есть недостаток. Она не справляется с циклическими зависимостями. Например, когда объект A ссылается на B, а B ссылается на A. Их счётчик ссылок никогда не опустится ниже 1. Хотя, в теории, если на A ничего не ссылается извне, то и B получить невозможно. Для циклических зависимостей требуется очистка всего набора данных за раз.

Поэтому в JVM используются иные алгоритмы, которые просматривают программу как направленный граф и проверяют доступность нод из корней GC. Для понимания работы JVM нужны следующие факты:

- для запуска программы в любой момент времени JVM работает с какими-то объектами напрямую, поэтому они абсолютно необходимы;
- эти объекты вызывают методы или свойства объектов, на которые в какой-то момент времени у них есть ссылка, так что эти объекты нельзя удалять;
- JVM никогда не теряет никакие объекты, которые были в ней созданы, так что остаётся только вычислить, что какие-либо объекты не нужны сейчас или перестанут быть нужны в скором времени.

Таким образом JVM анализирует весь граф, находит объекты, которые не могут быть достигнуты и планирует их удаление. Процесс поиска недостижимых объектов называется **mark** (так как JVM помечает нужные объекты и смотрит, что осталось). Момент очисктки памяти называется **sweep**.

Общая идея между всеми алгоритмами различных JVM следующая:

- мы начинаем с набором объектов;
- мы делаем объекты - изначально они не помечены, но мы помечаем их в ходе проверки;
- после того, как не осталось отмечаемых объектов - мы освобождаем память от неотмеченных;
- возможные оптимизации памяти:
  - из-за фрагментации памяти периодически GC производит дефрагментацию - перемещает объекты в памяти ближе друг к другу чтобы между ними не оставалось свободных сегментов. Таким образом освобождается место под большие объекты, которые могут создаваться в будущем. При этом приходится обновлять все указатели на перемещённые объекты. 
  - другой вариант - скопировать все доступные объекты в новый сегмент памяти и обновить указатели. Это быстрее, чем дефрагментация, но требует больше места.

Смысл примерно для всех одинаков, однако разные JVM реализуют это по-разному.

Например, в HotSpot объект помечается через специальный бит в хедере (*object header*), это такой набор метаданных, который лежит в каждом объекте в JVM. Размер хедера соответствует разрядности системы. Таким образом, запакованный Int в 64-разрядной системе будет весить в три раза больше, чем обычный int (32 сам int + (32 + 32) на метаданные).


