# Garbage collector

Пример

```scala
println(
  List(1,2,3,4,5,6,7).foldLeft("") { (s, i) => 
    s"$i / $s \ $i "
  }
)
// 9 / 8 / 7 / 6 / 5 / 4 / 3 / 2 / 1 / \ 1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8 \ 9
```

В этом варианте мы создаём много временных объектов - List, лямбда-функцию, промежуточные строки и финальную строку после fold. Нам не нужны все эти объекты после вывода строки в консоль.

Впервые возможность очистки памяти без вызова `free` на каждом указатели появилась в Lisp. Идея была в том, что программа сама будет отслеживать нужные и ненужные части программы. Такая идея принята и в JVM

## GC Root

Сначала нужно разобраться что такое "мусор" и какие объекты считаются "нужными".

Есть объекты, которые можно получить снаружи хипа.Стек-фреймы, нативный JVM код или глобальные переменные имеют прямой доступ к таким объектам и могут потенциально быть использованы, поэтому они не могут быть мусором "по определению". Такие объекты называются GC roots (корневые). В JVM это:

- системные классы JVM;
- запущенные треды, занятые блоки synchronized, ожидающие треды;
- локальные переменные в фреймах (пока фрейм существует - внутренние переменные считаются нужными);
- JNI переменные и стек нативного кода (там память очищается вручную программистом, например в подключенном коде на C);
- особые случаи: 
  - объекты с методом `finalize` (GC должен дёрнуть этот метод перед сбором, устарело в Java 9);
  - `unreachable` объекты, недоступные из кода, но помеченные анализатором как корни. Например, средства мониторинга могут форсить JVM сохранять объекты.

Когда у нас есть корни GC (какие-то объекты) - можно проверять, на какие объекты они имеют сильную ссылку (это все обычные ссылки кроме ссылок, сделанных через `java.lang.ref.WeakReference[T]`). Мы проверяем эти объекты и так далее. Таким образом мы получим список всех достижимых объектов - либо "по определению" (GC roots), либо неявно через сильные ссылки внутри корневых объектов. Всё остальное может быть собрано GC для освобождения памяти.

Слабые ссылки могут быть полезны когда мы пытаемся экономить память на объектах, которые легко перевычислить. Их метод `get()` может вернуть `null`, который следует проверять. Например, это может быть использовано в кэшировании.










