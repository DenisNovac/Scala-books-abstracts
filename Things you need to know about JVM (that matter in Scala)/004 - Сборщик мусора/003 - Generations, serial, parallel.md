# Generations

Объекты в памяти не одинаковы для HotSpot JVM. Чем моложе объект - тем больше шанс, что скоро он станет не нужен. Чем больше итераций GC пережил объект - тем больше шанс, что он переживёт следующие.

HotSpot разделяет объекты в памяти хипа на несколько видов:

- Young Gen - место для всех новых объектов, которые с большим шансом нужно будет очистить. Делится на:
  - Eden - новейшие объекты;
  - S0 или S1 - тут HotSpot оптимизирует память так, что выжившие объекты копируются туда-сюда (это дешевле, чем дефрагментация) между этими двумя пространствами, пока наконец не помещает их в следующий раздел.
- Old Gen - объекты тут дефрагментируются в пределах памяти с обновлением указателей, а не копируются. Это медленнее, но и операций над такими объектами GC делает немного.

В хедерах объектов есть поле age, которое используется в алгоритмах GC.

## Serial collector 

`-XX:+UseSerialGC`

Такой GC использует один тред чтобы ходить по графу, помечать объекты и очищать память. 

Может возникнуть ситуация, когда одна ссылка на объект будет перемещена из одной переменной в другую так, что вторая переменная уже была пройдена GC (например, когда была пустой). Тогда GC потеряет ссылку на такой объект и удалит его, хотя он нужен.

Для исключения таких ситуаций, Serial останаливает все треды программы (**GC pause/Stop The World/STW**) на время сборки мусора. Это время может быть очень заметным, иногда переходить на минуты. Сейчас такой алгоритм практически не используется.

## Parallel collector

`-XX:+UseParallelGC`

Такой GC тоже действует через STW, однако работает параллельно в нескольких тредах, что ускоряет работу.

В обоих случаях STW может быть важным недостатком для некоторых приложений, которым требуются быстрые интерактивные и вычисления. В худших случаях JVM может быть приостановлена на минуты.

## Concurrent Mark-Sweep (CMS)

`-XX:+UseConcMarkSweepGC`

Это первый алгоритм, который пытались реализовать без остановки приложения. Он всё ещё использует STW, но не во время каждой операции.

Он имеет несколько фаз:

- initial mark - работает через STW, считает Old Gen изначально отмеченным;
- concurrent marking - работает с Olg Gen и проверяет, какие действительно нужно отметить;
- remark - опять с STW, перепроверяет недостижимые объекты во время предыдущей фазы;
- concurrent sweep - освобождение памяти делает конкурентно, но не трогает память в Old Gen. Если память очень фрагментирована - запускает serial GC;
- resetting - подготовка к следующему GC, скидывает атрибуты объектов, использованные для алгоритма.

Обычно STW-фазы очень быстрые, но в редких случаях происходит долгая работа с памятью посредством Serial.

Это дефолтный алгоритм Java 8, устаревший в Java 9 и будет убран в Java 14.

## Garbage First (G1)

`-XX:+UseG1GC`

В нём предпринята попытка изменить работу в памяти. Вместо больших регионов памяти (old/young) теперь множество маленьких (1-4 MB по умолчанию), которые принадлежат к Eden, Survivor, Old, Humongous (в них хранятся объекты, которые занимают более половины памяти в пределах региона)). С маленькими регионами работа быстрее, чем с большими (например, при копировании объектов).

Отслеживает объекты G1 через **Remembered Sets**, что позволяет не сканировать весь хип.

Он всё ещё использует довольно много STW, но работа с памятью помогла ускорить все этапы работы, так что он стал дефолтным алгоритмом в HotSpot.

## Zero Garbage Collection (ZGC)

`-XX:+UnlockExperimentalVMOptions -XX:+UseZGC`

Цели алгоритма: 
- максимум 10 ms задержки при работе GC;;
- работа на терабайтных хипах;
- не более 15% понижения проходной способности по сравнению с G1;
- меньше параметров для настройки;

ZGC не использует идею поколений, но все ещё использует регионы (ZPages) трёх размеров - для объектов до 256кб, до 4мб и более 4мб. Каждую остановку он пытается за 10 мс сделать как можно больше, но никогда не останавливать приложение на большее время.

ZGC умеет в non-uniform memory access (но только под Linux x64).

Кроме того, ZGC использует цветные указатели (**colored pointers**) и **load barriers** 

Цветные указатели позволяют описать фазу GC, в которой находится объект (это позволяет прерывать работу алгоритма и продолжать с того же места, либо работать алгоритму в конкуретном режиме).

Load barrier - это возможность сменить цвет указателя при загрузке из хипа на положительный, чтобы отменить подготовку объекта к очистке.

## Работа без GC

`-XX:+UseEpsilonGC`

Это сборщик мусора, который никогда не освобождает память. Смысл использования такого "сборщика" в том, чтобы писать очень маленькие и живущие недолго программы. Другой вариант - написание бенчмарков.

