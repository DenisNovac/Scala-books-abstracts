# Классы и объекты

Всё, что не является примитивом в JVM является объектом. Объекты могут иметь методы, создаются словом `new` и хранятся в хипе, а не стаке.

Массивы имеют отдельный префикс в JVM, хотя и являются объектами (`L ClassName` - класс, `[` - массив)

Кроме того, байткод теряет типизированные параметры. В `Array[A]`  `A` превратится в `Object`, а функции типа `A => Unit` в `scala.Function`. 

## Из чего состоит класс

В C++ компилятор просматривает свойства класса и выделяет память согласно сумме свойств. Для обращения к ним используется адрес какого-то из свойств + оффсет, основанный на его размере. 

Объект - это часть памяти, которая может быть прочитана исходя из определения класса.

### Конструктор

C и C++ выдяляют память так, что там может быть что угодно. Значения неинициализированных переменных практически случайны, поэтому важно использовать конструкторы.

В JVM более безопасное и дорогое поведение - она зануляет всю выделенную память примитивов (0 для всех чисел или false), а все ссылочные типы равняет null. 

### Методы

В C++ методы не хранятся вместе с объектами. Они хранятся в отдельном месте, а при компиляции к ним добавляется дополнительный аргумент - вызывающий объект. Например, метод `User#sayHiTo(other: String)` будет преобразован в `sayHiTo(this: User, other: String)`, а все вызовы аргументов внутри будут написаны через `this`. 

Для оверрайдов там используются виртуальные `virtual` методы (только их можно переопределять) и таблицы виртуальных методов. Тогда в классе создаётся таблица `vtable`, которая содержит список всех виртуальных методов класса (и его родителей) в определённом порядке в виде ссылок на функции. Эта таблица учитывается в весе объекта. Всем указателям на функции внутри этого объекта присваиваются адреса последнего оверрайда.

Когда вирутальный метод вызван - он просматривает индекс метода в таблице (он известен на этапе компиляции), берёт адрес функции и вызывает его, передавая `this`.

В Java все методы виртуальны по умолчанию, поэтому такое ключевое слово не нужно. Зато в байткоде есть фраза `invokevirtual` в моменты вызова методов объекта.

### Свойства

В Scala классы никогда не имеют публичных свойств. Даже если объявить `class Props(val test: Int, var mut: String)`, под капотом создадутся методы, аналогичные стандартным get и set (только для var). При этом сами переменные всегда будут private. Это касается только свойств, внутри класса локальные переменные остаются переменными.

Дефолтные параметры методов типа `def method(i: Int = 1)` в JVM пропадают (остаётся только сам метод). Сами значения превращаются в функции внутри класса типа `method$default$1`. Scala сама передаёт туда дефолтные параметры вызывая эти функции.

Очевидно, из Java дефолтные методы работать вообще не будут (но можно дёргать их через рефлексию).

### Наследование

В `C++` можно наследовать сколько угодно классов, но придётся переопределять конфликтующие методы.

В `Java` наследовать можно только один класс, зато сколько угодно интерфейсов. В JVM интерфейсы это не то же самое, что класс с абстрактными методами без параметров. Это отдельная конструкция. 

```scala
trait A {
  def doSomething(): Unit
}

trait B1 extends A {
  override def doSomething(): Unit = println("I am B1")
}

trait B2 extends A {
  override def doSomething(): Unit = println("I am B2")
}

class C extends B1 with B2
```

Трейт `Scala` отличается тем, что может иметь имплементированные методы и параметры. Кроме того, конфликтующие методы не нужно переопределять. Например, запись `class C extends B1 with B2` при наличии конфликтов между B1 и B2 будет использовать метод из B2 (либо свой оверрайд). Проверка методов идёт слева-направо. Причём в `Scala`  `B1 with B2` это то же самое что `B2 with B1`, а вот в `Dotty` будут `compound` типы, которые решают эту проблему.

Однако, JVM не позволяет множественные наследования. Поэтому в Scala используется `trait linearization`. 

- Под капотом `trait A` будет обычным интерфейсом;
- `trait B1` будет интерфейсом (наследуемым от `A`) и абстрактным классом `B1$class`, который будет содержать статичный метод (так как `B1` имеет имплементированный метод);
- `trait B2` будет таким же;
- `C` будет обычным классом, имплементируюзим два интерфейса. А `doSomething()` он будет вызывать из абстрактного класса `B2`, так как он последний в списке.

В Java 8 появились дефолтные методы интерфейсов, поэтому Scala 2.12 стала генерировать более простой код. Теперь `B1` и `B2` это интерфейсы с дефолтными и статичными методами, а `C` просто вызывает статичный метод последнего из интерфейсов.


### Разграничение доступа

Под капотом JVM не видит разницы между public и protected, этим занимается компилятор. Однако, для определённых оптимизаций `private` на уровне JVM остаётся.

### Объекты (модули)

JVM не позволяет иметь функции без класса. Максимум чего можно достичь - static методы, для которых не нужна имплементация класса.

Но класс нельзя передать в функцию, чтобы она вызвала статичный метод. Кроме того, статичные методы не могут наследовать поведения или имплементировать интерфейсы.

OOP обычно использует синглтон для получения одного глобального инстанса, что решает эту проблему. Имплементацию можно передать со всеми методами, которые наследуют интерфейсы и не являются статичными.

Scala имеет поддержку синглтонов на уровне языка - `object` (или "модули" как их называют в коде компилятора). В Java `object X` будет транслирован в два класса - `public final class X` и `public final class X$`. Второй класс - синглетон со статичным конструктором, который всегда отдаёт один и тот же инстанс. Именно в нём определены все методы объекта `X`. А первый класс - просто обёртка, которая перенаправляет методы объекта `X` во второй класс.

```scala
object ThisIsSingleton {
  def thisIsMethod(): Unit = println("hello")
}
```

Примерно

```java
public final class ThisIsSingleton {
  void thisIsMethod() {
    ThisIsSingleton$.MODULE$.thisIsMethod();
  }
}

public final class ThisIsSingleton$ {
  public final static ThisIsSingleton$ MODULE$;

  static { // статичный, сохраняет в переменную - результат будет одним и тем же для всех new ThisIsSngleton$
    MODULE$ = new ThisIsSingleton$(); 
  }

  void thisIsMethod() {
    scala.Predef$.MODULE$.println("hello");
  }
}
```

Очевидно, что из Java можно использовать эти классы как угодно, а вот в Scala они будут не видны.

Первый класс всегда является обёрткой, а настоящие методы уходят в класс с $. Если бы мы имплементировали интерфейс типа `object X extends A` - оверрайды тоже были бы во втором классе. а первый остался бы обёрткой. Смысл этого обёрточного класса в том, чтобы вызывать его из Java, однако всё наследование тут пропадает.

#### Объекты-компаньоны

Объекты расширяют пространство поика имплиситов. Таким образом метод `def encode[T: Encoder](t: T) = t.encode` будет проверять наличие неявного `Encoder` в компаньоне `T` и экстеншен-метода `encode` в нём.

## AnyVal

Иногда мы хотим иметь обёртку в нашем коде:

```scala
case class Age(value: Int)
```

Такая обёртка всегда будет затрачивать ресурсы при выделении памяти на внутренний Int. Однако, можно заставить Scala избегать дополнительных затрат, снаследовав класс от `AnyVal`.

```scala
case class Age(value: Int) extends AnyVal
```

Например:

```scala
case class Person(age: Age)
```

Под капотом переменная age будет Int, а не Age. Однако, в ряде случаев вроде передачи в функции и паттерн матчинга упаковка (boxing) переменной неизбежна.

Другой вариант - это тегированные типы (предоставляемые библиотеками типа Shapeless):

```scala
sealed trait AgeTag

type Age = Int @@ AgeTag // под капотом просто тип Int with AgeTag
```

В Dotty присутствует ещё одна альтернатива - `opaque` типы, которые похожи на встроенный в язык генератор тегированных типов.





