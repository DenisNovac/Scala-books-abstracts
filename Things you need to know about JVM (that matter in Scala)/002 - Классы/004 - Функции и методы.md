# Функции и методы

Метод - это просто функция в объекте? На самом деле, это не совсем так.

Методы - это то, что объекты вызывают через виртуальные таблицы. 

В JVM уже давно есть функции, принимаемые в лямбда-выражениях. Даже стандартная библиотека имеет вещи вроде `java.lang.Runnable` (`() => ()` по сути) и `java.lang.Callable[T]` (`() => T`). Таким образом, функции, в отличие от методов, являются объектами. Их можно считать функциями, так как:

В Java 8 появился синтаксический сахар для лямбда-выражений - транслирование `args -> result` и интерфейс `Function<I,O>`.

- У них есть один метод для вызова чтобы запустить вычисление;
- объекты в JVM могут иметь closures.

**Closure** - это возможность получения доступа к данным и методам из контекста, где объект был создан:

```scala
trait MyFunction[In, Out] {
  def apply(in: In): Out
}

class MultiplyBy(multiplier: Int) {
  def getFunction: MyFunction[Int, Int] = new MyFunction[Int, Int] {
    def apply(in: Int) = in * multiplier // Внутренний объект может использовать внешнюю переменную
  }
}

```

На уровне компиляции это создаёт новый класс-наследник MyFunction без ссылки на него (**анонимный**, в байткоде имеет имя `public final class MultiplyBy$$anon$1`), который является так же внутренним классом. Такие классы хранят скрытую ссылку на объект, который их создал (тут это инстанс `MultiplyBy`). Анонимная функция называется **лямбдой**.


