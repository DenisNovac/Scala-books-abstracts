## Параметризованные классы

JVM не знает о генериках или типизированных параметрах. В Java этот функционал появился в 1.5. До этого контейнеры типа List имелии тип `List<Object>`. Это было не очень безопасно, поэтому было решено привнести в язык обобщения (generics).

Для этого есть два пути:

- `reified generics` (материальные обобщения) - для каждого `List[A]` под капотом создавать класс `List[String]` и подобные;
- `type erasure` (стирание типов) - под капотом одна имплементация - `List[Object]` (на самом деле, может быть и более точный верхний тип, например если генерик ограничен `[A <: Foo]`). Касты типов данных делает компилятор.

Второй вариант был использован в JVM. Он снижает размер итоговой программы и позволяет передавать типы в рантайме. С другой стороны, касты примитивных типов замедляют производительность, а рантайм не знает конкретные типы.

Поэтому такой код 

```scala

def matchMe[T](t: T) t match {
  case _: T => "It is T"
  case _ => "It is not T"
}
```

Ничего на самом деле не проверит: *warning: abstract type pattern T is unchecked since it is eliminated by erasure*.

Можно обойти это через рефлексию и ClassTag, однако обычно PM происходит на ADT и в этом нет необходимости.

### @specialized

На самом деле, в Scala мы можем получить поведение `reified generics` используя аннотацию `@specialized`:

```scala
case class Cons[@specialized(Int) T](head: T, tail: List[T])
```

В данном примере для `Cons[Int]` будет сгенерирована специальная отдельная имплементация. Но злоупотреблять этим не следует. 

