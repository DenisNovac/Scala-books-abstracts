# Case class, case object

Создание `case class` на деле генерирует два класса: `User` и `User$` (по сути это объект-компаньон).

- объект-компаньон генерируется с `apply` (поэтому можно создавать без `new`) и с методом `unapply` (позволяет использовать паттерн-матчинг, так как объект становится экстрактором);
- все свойства `val` по умолчанию;
- класс реализует `Product` (позволяет итерировать по кейз-классу будто это массив свойств) и `Serializable` (используется в JVM для сериализации объектов внутренними методами) трейты;
- класс получает реализации методов `hashcode`, `equals` и `toString`. Они использую свойства в том порядке, в котором они указаны (например, для сравнения или отображения в строке).

`case class` - это немутабельный класс для моделирования данных. Не нужно использовать его только чтобы не писать `new`. 

`case class`-ы имеют ограничения - case class нельзя наследовать от другого case class-а (напрямую или транзитивно). Это связано с тем, что они начнут переопределять методы `hashcode` и остальные друг у друга, в результате чего их невозможно будет нормально использовать.

`case object` практически то же самое (по сути case class + object), только product пустой и имплементация хранится в синглтоне.

## Sealed-иерархии (ADT)

`sealed trait` даёт возможность проверки, что количество возможных имплементаций некоторого трейта конечно. На основе этого scalac проверяет исчерпание вариантов в паттерн матчинге.  


