# Рефлексия

Некоторые вещи тяжело сделать используя только систему типов. Например, систему плагинов. Она может подключаться через добавление JAR-файла, который написал и скомпилировал другой пользователь.

## Class[_]

Class[_] - это элемент рефлексии, содержащий объект с информацией о каком-либо типе.

Рефлексия позволяет узнавать конструкторы, методы и поля класса, а так же умеет отличать инстанс от типа.

```scala
classOf[String].getConstructors

classOf[String].getDeclaredMethods

classOf[String].isInstance("something") // true
```

Кроме того, таким образом можно создавать объект или дёргать методы в обход системы типов.

## Как получить Class[_]

При вызове `classOf[SomeType]` понятно, что нам известен `SomeType`. Но можно сделать это иначе:

- По имени:

```scala
Class.forName("java.lang.String")
```

- Через ClassLoader:

```scala
val classes = classOf[ClassLoader].getDeclaredField("classes")
classes.setAccessible(true) // делаем поле публичным

```

Таким образом можно найти, к примеру, все классы, имплементирующие какой-либо интерфейс. Хотя, есть библиотеки, которые умеют это делать более оптимально (через байткод).

Эта идея лежит в основе приёмов:

- DI в библиотеках типа Spring и Guice работает на рефлексии (автоматически создаёт нужные объекты и их аргументы по цепочке);
- аннотации в Spring и Guice, Hibernate. На самом деле при компиляции они помещаются внутрь `Class[_]`, откуда их можно достать средствами рефлексии.

## Недостатки

- рантайм-рефлексия не учитывает типобезопасность вообще - нужно проверять существование классов, методов и т.д.;
- компилятор не предупреждает об ошибках в случае нарушенной конфигурации;
- оптимизации JVM не работают (методы вызываются не обычным образом, а напрямую), а стак трейс в случае ошибки будет тяжело разбирать;
- рефлексия имеет оверхед при исполнении.

Самая большая проблема DI-фреймворков на рефлексии - они считают каждый класс "плагином". Рефлексия необходима в некоторых случаях, но условный DI можно реализовать и без неё (Dagger, Distage).

Конечно, монады тоже имеют оверхед, но к ним применяются оптимизации JVM и они проверяемы на этапе компиляции.

Примеры разницы подходов Scala и Java:

- Jackson для Java - рантайм-рефлексия;
- Circe для Scala - компайлтайм-рефлексия и макросы.

- Dozer, EZMorth, Morph - трансформации объектов в Java на аннотациях и рефлексии;
- Chimney для Scala - макросы.





