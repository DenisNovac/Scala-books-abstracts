# Рефлексия Scala

## Рантайм

В Scala есть собственные инструменты райнтайм-рефлексии. Это связано как с дополнительными типами Scala, так и собственной необходимостью в использовании рефлексии. Например, `TypeTag` вместо `ClassTag`. 

refined-типы под капотом переписываются в рефлексийный вызов нужного метода

```scala
trait MyTrait

def useMethod(x: MyTrait {def methodX: Int}) = x.methodX

// под капотом примерно следующее

def reflMethod$Method1(clazz: Class[_]): java.lang.reflect.Method = {/* рефлексия */}

def uesMethod(x: MyTrait): Unit =
  try {
    reflMethod$Method1(in.getClass).invoke(in)
  } catch {
    case e: java.lang.reflect.InvocationTargetException
  }

```

pattern matching под капотом просто состоит из if-else с `instanceOf`.

## Компайлтайм рефлексия в Scala:

- компилятор знает о типах, поэтому проверяет их;
- библиотеки типа Circe позволяют создавать рекурсивное выведение тайпклассов (например, используя готовые кодеки для более мелких подтипов);
- макросы создают код во время компиляции исходя из информации, которая доступна в том месте, где они написаны.

Таким образом, большинство ситуаций, где Java использовала бы рантайм-рефлексию, покрыты компайлтайм-рефлексией Scala. 

