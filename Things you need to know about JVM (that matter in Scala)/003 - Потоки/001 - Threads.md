# Потоки

JVM изначально поддерживала многопоточность. Один интерфейс работал на всех поддерживаемых платформах. Почему FP библиотеки в Scala решили написать свои абстракции поверх встроенных?

## Параллельное и конкурентное исполнение

Конкурентное исполнение означает, что компьютер имеет один поток выполнения, который переключается между несколькими задачами, выдавая на каждую определённое время. Например, когда компьютер имеет 1 CPU.

Параллельное исполнение означает, что процессы не пересекаются между собой. Например, когда у нас 2 CPU - мы можем запустить два процесса от начала до конца без их приостановки.

Что если бы мы хотели иметь параллелизм не для двух программ, а в пределах одной программы? Например, процесс загрузки отдельный от процесса работы с пользователем? Есть 2 возможных пути:

- forks: на уровне системы программа превращается в две программы. Это популярный вариант для POSIX - MacOS, Linux и подобных;
- threads: тут примерно так же - две программы работают одновременно, но они работают в одной памяти, поэтому система видит их как одну программу. Система назначает субпрограммы на CPU и знает, что она многопоточна, но внешне всё выглядит как одна программа.

### M:N треды

Практически никогда не бывает ситуаций, когда количество процессов напрямую соответствует количеству ядер. Обычно у нас M тредов и N процессоров, что означает, что нам нужно конкурентно исполнять эти треды между разными CPU.

### JVM-треды

В JVM были выбраны треды в качестве абстракции для использования. Поэтому в JVM многопоточность работает в одной памяти и система видит только одну JVM на одну программу.

Код `new Thread().start()` создаёт новый тред в системе (на разных системах используется разная имплементация) и этот новый тред запускает метод `run()` этого треда.

На самом низком уровне мы можем использовать `new Thread` и оверрайднуть `run()` или передать `java.lang.Runnable()` (он имеет один метод и можно использовать синтаксический сахар `new Thread(() => {...}.start())`). Тред закончится когда закончится выполнение `run`.

Треды могут и не кончаться:

- если там бесконечный цикл или вроде того;
- этот тред является демоном. Такие треды можно обозначить перед запуском: `thread.setDaemon(true)`. Такие треды с точки зрения JVM являются некритичными. Если в программе работают только они, а все остальные треды кончились - JVM может завершить работу сама.

В Scala дефолтные `ExecutionContext` и `Scheduler` используют тред-пулы, наполненные тредами-демонами. Иначе бы пришлось проверять законченность работы и закрывать тред-пулы самому. Поэтому все асинхронные операции на них никогда не выполняются сами по себе:

```scala
Future{
  println("hello")
}
```

Чтобы выполнить такой запрос - нужно использовать что-то, что заставит текущий тред (который не является демоном) ждать тред-демон. Например, у Future есть метод Await.

Библиотеки используют специальные треды для выполнения таких программ. Например, `IOApp` из `cats.effect`. При этом все внутренние треды являются демонами.

Использование тред-пулов оправдано тем, что создание нового треда - это дорогая операция.






