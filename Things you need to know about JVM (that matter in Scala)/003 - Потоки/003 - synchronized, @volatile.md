# synchronized, @volatile

## synchronized

До этого момента мы говорили о параллельных независимых вычислениях без общих ресурсов. Что, если мы хотим, чтобы два вычисления использовали один ресурс?

Они могут начать менять общий ресурс одновременно. Например, на банковском аккаунте 100 рублей. Первый тред снимает с него 10 рублей, второй кладёт 50, а в результате получается 90. Они пересеклись во времени, и первый тред сделал операцию финальной записи позже всего.

В таких ситуациях мы можем хотеть чтобы определённые места затрагивал один тред за раз. Многие ЯП используют **mutexes**/**мьютексы** (*mutual exclusion*). Это специфичный объект, который позволяет использовать функцию `lock()` в критичных секциях. Они имплементированы таким образом, что функция возвращает выполнение мгновенно (если объект свободен) или не возвращает очень долго (пока объект не освободится функцией `unlock()`). Ради удобства некоторые языки имеют специальные блоки, которые вызывают эти функции сами.

В Java:

```java
void methodWithCritical() {
  synchronized(this){
    // only one thread at once
  }
}
```

В Scala это просто `synchronized{ ... }`.

`synchronized` привязан к объекту. Причём существует паттерн использования объекта в качестве монитора. Мы можем использовать внешний объект с блоком `synchronized` чтобы работать с несколькими объектами внутри в качестве прокси.

Однако, и тут можно напутать. Например, вызвать `synchronized` в нескольких местах так, что треды начнут создавать дедлоки (бесконечно ожидать другие треды). В сложных взаимосвязях объектов дедлок может быть весьма неочевиден.

Ещё в Java есть ключевое слово `public synchronized void log(String txt)`, но это эквивалент обычного метода `log`, всё тело которого обёрнуто в `synchronized`. В Scala такого ключевого слова нет.

## @volatile

Вторая проблема - это оптимизации CPU. Для ускорения вычислений они имеют кэши (L1, L2, L3), из-за чего могут не видеть изменения, сделанные другими тредами. 

Поэтому мы имеем специальную аннотацию в Scala (в Java это ключевое слово):

```scala
def main(args: Array[String]): Unit = {
  @volatile var counter = 0
  ...
}
```

Таким образом, эта переменная всегда будет считываться CPU заново в каждом из тредов.





